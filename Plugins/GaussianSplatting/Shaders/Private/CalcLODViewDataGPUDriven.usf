// Copyright Epic Games, Inc. All Rights Reserved.

// Purpose: GPU-driven LOD splat processing - processes ALL LOD splats, rejects non-selected ones
// This avoids CPU readback entirely, achieving maximum performance

#include "/Engine/Private/Common.ush"
#include "/Plugin/GaussianSplatting/Private/GaussianDataTypes.ush"

// Input: LOD splat data buffer (all LOD splats)
StructuredBuffer<FGaussianGPULODSplat> LODSplatBuffer;

// Input: Maps each LOD splat index to its owning cluster ID
StructuredBuffer<uint> LODSplatClusterIndexBuffer;

// Input: Bitmap indicating which parent clusters are selected for LOD rendering
// Written by ClusterCulling, bit set = cluster's LOD splats should be rendered
StructuredBuffer<uint> LODClusterSelectedBitmap;

// Output: View data for rendering
RWStructuredBuffer<FGaussianSplatViewData> ViewDataBuffer;

// Output: Atomic counter for valid LOD splat output
RWStructuredBuffer<uint> LODSplatOutputCountBuffer;

// Transforms
float4x4 LocalToWorld;
float4x4 WorldToClip;
float4x4 WorldToView;
float2 ScreenSize;
float2 FocalLength;

// Parameters
uint TotalLODSplats;      // Total number of LOD splats to process
uint OutputStartIndex;    // Start index in ViewDataBuffer (= SplatCount)
float SplatScale;
float OpacityScale;

// Check if a cluster's LOD splats should be rendered
bool IsClusterLODSelected(uint clusterIndex)
{
	uint bitmapIndex = clusterIndex / 32;
	uint bitMask = 1u << (clusterIndex % 32);
	return (LODClusterSelectedBitmap[bitmapIndex] & bitMask) != 0;
}

[numthreads(256, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint lodSplatIndex = DispatchThreadId.x;
	if (lodSplatIndex >= TotalLODSplats)
	{
		return;
	}

	// Lookup which cluster owns this LOD splat
	uint clusterID = LODSplatClusterIndexBuffer[lodSplatIndex];

	// Atomically reserve an output slot
	// We always write something (valid or invalid) to maintain consistent output
	uint outputSlot;
	InterlockedAdd(LODSplatOutputCountBuffer[0], 1, outputSlot);
	uint outputIndex = OutputStartIndex + outputSlot;

	// Check if this cluster was selected for LOD rendering
	if (!IsClusterLODSelected(clusterID))
	{
		// Cluster not selected - mark invalid, will be sorted to end
		FGaussianSplatViewData viewData;
		viewData.ClipPosition = float4(0, 0, 0, -1);  // Invalid marker
		viewData.PackedColorRG = 0;
		viewData.PackedColorBA = 0;
		viewData.Axis1 = float2(0, 0);
		viewData.Axis2 = float2(0, 0);
		viewData.ClusterID = clusterID;
		viewData.Padding = 0;
		ViewDataBuffer[outputIndex] = viewData;
		return;
	}

	// Load LOD splat data
	FGaussianGPULODSplat lodSplat = LODSplatBuffer[lodSplatIndex];

	float3 localPos = lodSplat.Position;
	float4 rotation = lodSplat.Rotation;
	float3 scale = lodSplat.Scale * SplatScale;

	// Unpack color and opacity
	float4 colorOpacity = UnpackLODSplatColor(lodSplat.ColorOpacityPacked);
	float opacity = colorOpacity.a * OpacityScale;

	// Transform to world space
	float4 worldPos = mul(float4(localPos, 1.0), LocalToWorld);

	// Transform to clip space
	float4 clipPos = mul(worldPos, WorldToClip);

	// Cull if behind camera
	if (clipPos.w <= 0.0)
	{
		FGaussianSplatViewData viewData;
		viewData.ClipPosition = float4(0, 0, 0, -1);  // Invalid marker
		viewData.PackedColorRG = 0;
		viewData.PackedColorBA = 0;
		viewData.Axis1 = float2(0, 0);
		viewData.Axis2 = float2(0, 0);
		viewData.ClusterID = clusterID;
		viewData.Padding = 0;
		ViewDataBuffer[outputIndex] = viewData;
		return;
	}

	// Transform to view/camera space for covariance projection
	float4 viewPos = mul(worldPos, WorldToView);

	// Clamp view position to prevent extreme projections
	float tanFovX = (ScreenSize.x * 0.5) / FocalLength.x;
	float tanFovY = (ScreenSize.y * 0.5) / FocalLength.y;
	float limX = 1.3 * tanFovX;
	float limY = 1.3 * tanFovY;
	viewPos.x = clamp(viewPos.x / viewPos.z, -limX, limX) * viewPos.z;
	viewPos.y = clamp(viewPos.y / viewPos.z, -limY, limY) * viewPos.z;

	// Calculate 3D covariance from rotation and scale
	float3x3 cov3D_local = CalcCovariance3D(rotation, scale);

	// Transform covariance from local space to world space
	float3x3 localToWorldRot = (float3x3)LocalToWorld;
	float3x3 cov3D_world = mul(transpose(localToWorldRot), mul(cov3D_local, localToWorldRot));

	// Get view matrix (upper 3x3)
	float3x3 viewMat = (float3x3)WorldToView;

	// Project to 2D screen covariance
	float2x2 cov2D = CalcCovariance2D(cov3D_world, viewMat, viewPos.xyz, FocalLength);

	// Decompose into principal axes
	float2 axis1, axis2;
	DecomposeCovariance2D(cov2D, axis1, axis2);

	// Convert axes to NDC space
	axis1 = axis1 / ScreenSize * 4.0;
	axis2 = axis2 / ScreenSize * 4.0;

	// Safety check: clamp axes to reasonable NDC range
	float maxAxisSize = 2.0;
	if (any(isnan(axis1)) || any(isinf(axis1)) || length(axis1) > maxAxisSize)
	{
		axis1 = float2(0.01, 0.0);
	}
	if (any(isnan(axis2)) || any(isinf(axis2)) || length(axis2) > maxAxisSize)
	{
		axis2 = float2(0.0, 0.01);
	}

	// Frustum culling
	{
		float2 ndcCenter = clipPos.xy / clipPos.w;
		float2 ndcExtent = abs(axis1) + abs(axis2);

		if (ndcCenter.x - ndcExtent.x > 1.0 || ndcCenter.x + ndcExtent.x < -1.0 ||
			ndcCenter.y - ndcExtent.y > 1.0 || ndcCenter.y + ndcExtent.y < -1.0)
		{
			FGaussianSplatViewData viewData;
			viewData.ClipPosition = float4(0, 0, 0, -1);  // Invalid marker
			viewData.PackedColorRG = 0;
			viewData.PackedColorBA = 0;
			viewData.Axis1 = float2(0, 0);
			viewData.Axis2 = float2(0, 0);
			viewData.ClusterID = clusterID;
			viewData.Padding = 0;
			ViewDataBuffer[outputIndex] = viewData;
			return;
		}
	}

	// LOD splats use pre-computed color (no SH evaluation needed)
	// Color is already in linear space (was converted during LOD generation)
	float3 finalColor = colorOpacity.rgb;

	// Pack and store view data
	FGaussianSplatViewData viewData;
	viewData.ClipPosition = clipPos;
	viewData.PackedColorRG = PackHalf2x16(finalColor.rg);
	viewData.PackedColorBA = PackHalf2x16(float2(finalColor.b, opacity));
	viewData.Axis1 = axis1;
	viewData.Axis2 = axis2;
	viewData.ClusterID = clusterID;  // Use cluster ID for debug visualization
	viewData.Padding = 0;

	ViewDataBuffer[outputIndex] = viewData;
}
