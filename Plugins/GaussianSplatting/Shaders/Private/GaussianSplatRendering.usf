// Copyright Epic Games, Inc. All Rights Reserved.

//RASTERIZATION, Vertex Shader + Pixel Shader

#include "/Engine/Private/Common.ush"
#include "/Plugin/GaussianSplatting/Private/GaussianDataTypes.ush"

// Vertex shader parameters
#if VERTEXSHADER
StructuredBuffer<FGaussianSplatViewData> ViewDataBuffer;
StructuredBuffer<uint> SortKeysBuffer;
uint SplatCount;
uint DebugMode;  // 0=off, 1=cluster colors, 2=LOD colors (future)
#endif

// Hash function to generate pseudo-random color from cluster ID
// Uses the same approach as Nanite debug visualization
float3 HashToColor(uint id)
{
	// Multiply by large prime for better distribution
	uint h = id * 2654435761u;

	// Extract RGB from different bit ranges
	float r = float((h >> 0) & 255) / 255.0;
	float g = float((h >> 8) & 255) / 255.0;
	float b = float((h >> 16) & 255) / 255.0;

	// Boost saturation for better visibility
	float3 color = float3(r, g, b);
	float maxVal = max(max(color.r, color.g), color.b);
	if (maxVal > 0.0)
	{
		color = color / maxVal * 0.8 + 0.2;  // Normalize and add minimum brightness
	}
	else
	{
		color = float3(0.5, 0.5, 0.5);
	}

	return color;
}

// Vertex shader output / Pixel shader input
struct FVertexOutput
{
	float4 Position : SV_POSITION;
	float2 LocalPos : TEXCOORD0;
	float4 Color : TEXCOORD1;
};

// Vertex shader: generate quad from instance data
FVertexOutput MainVS(
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID)
{
	FVertexOutput Output;

	// Quad corners based on vertex ID:
	// 0=(-1,-1), 1=(1,-1), 2=(-1,1), 3=(1,1)
	float2 corner;
	corner.x = (VertexId & 1) ? 1.0 : -1.0;
	corner.y = (VertexId & 2) ? 1.0 : -1.0;

	// Get sorted splat index
	uint splatIndex = SortKeysBuffer[InstanceId];
	FGaussianSplatViewData viewData = ViewDataBuffer[splatIndex];

	// Check validity (w <= 0 means invalid/behind camera)
	if (viewData.ClipPosition.w <= 0.0)
	{
		// Output degenerate triangle
		Output.Position = float4(0, 0, 0, 1);
		Output.LocalPos = float2(0, 0);
		Output.Color = float4(0, 0, 0, 0);
		return Output;
	}

	// NDC position of splat center
	float2 ndc = viewData.ClipPosition.xy / viewData.ClipPosition.w;

	// Use covariance-based axes for quad offset
	float2 offset = corner.x * viewData.Axis1 + corner.y * viewData.Axis2;

	// Unpack color
	float2 rg = UnpackHalf2x16(viewData.PackedColorRG);
	float2 ba = UnpackHalf2x16(viewData.PackedColorBA);
	float4 color = float4(rg.x, rg.y, ba.x, ba.y);

	// Debug mode: override color with cluster-based coloring (Nanite-style)
	if (DebugMode > 0)
	{
		color.rgb = HashToColor(viewData.ClusterID);
		// Keep alpha at a reasonable value for visibility
		color.a = max(color.a, 0.8);
	}

	Output.Color = color;

	// Final clip position
	Output.Position = float4(
		(ndc + offset) * viewData.ClipPosition.w,
		viewData.ClipPosition.z,
		viewData.ClipPosition.w
	);

	Output.LocalPos = corner;

	return Output;
}

// Pixel shader: Gaussian falloff with alpha blending
float4 MainPS(FVertexOutput Input) : SV_Target
{
	// Gaussian falloff matching Unity's implementation
	// Unity uses exp(-dot(pos,pos)) where pos goes to ±2 at edges
	// Our LocalPos goes to ±1 at edges, so we use exp(-4*distSq) to match
	// At corner (1,1): distSq=2, exp(-8) ≈ 0.00034, matching Unity's exp(-8) at (2,2)
	float distSq = dot(Input.LocalPos, Input.LocalPos);

	// Gaussian weight matching Unity's falloff
	float gaussianWeight = exp(-4.0 * distSq);

	// Apply Gaussian to alpha (saturate to match Unity's behavior)
	float4 color = Input.Color;
	color.a = saturate(gaussianWeight * color.a);

	// Premultiplied alpha
	color.rgb *= color.a;

	// Discard nearly transparent pixels for efficiency
	// Match Unity's threshold: 1/255 ≈ 0.00392
	if (color.a < 1.0/255.0)
	{
		discard;
	}

	return color;
}
