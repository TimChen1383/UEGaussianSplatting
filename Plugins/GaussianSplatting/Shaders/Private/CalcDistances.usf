// Copyright Epic Games, Inc. All Rights Reserved.

//For each splat, extracts Z coordinate from ViewDataBuffer.Converts depth to sortable uint

#include "/Engine/Public/Platform.ush"
#include "/Plugin/GaussianSplatting/Private/GaussianDataTypes.ush"

// Shader parameters
StructuredBuffer<FGaussianSplatViewData> ViewDataBuffer;
RWStructuredBuffer<uint> DistanceBuffer;
RWStructuredBuffer<uint> KeyBuffer;
uint SplatCount;
uint PaddedCount;

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 256
#endif

[numthreads(THREADGROUP_SIZE, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint splatIndex = DispatchThreadId.x;
	if (splatIndex >= PaddedCount)
	{
		return;
	}

	// Padding entries beyond actual splat count - sort to end
	if (splatIndex >= SplatCount)
	{
		DistanceBuffer[splatIndex] = 0xFFFFFFFF;
		KeyBuffer[splatIndex] = splatIndex;
		return;
	}

	// Load clip position from view data
	float4 clipPos = ViewDataBuffer[splatIndex].ClipPosition;

	// Invalid splat (behind camera) - marked with w <= 0
	if (clipPos.w <= 0.0)
	{
		DistanceBuffer[splatIndex] = 0xFFFFFFFF; // Sort to end
		KeyBuffer[splatIndex] = splatIndex;
		return;
	}

	// Calculate depth (Z/W for perspective, normalized to [0,1])
	float depth = clipPos.z / clipPos.w;

	// Convert to sortable uint for back-to-front sorting
	// UE uses reversed-Z: near=1, far=0. So ascending sort of depth values
	// naturally gives back-to-front order (far/small values first, near/large values last).
	uint depthBits = asuint(depth);

	// Flip sign bit for proper float-to-sortable-uint conversion
	// This ensures correct ordering for both positive and negative floats
	depthBits ^= (-(int)(depthBits >> 31)) | 0x80000000;

	// No inversion needed - UE's reversed-Z already gives the right order
	DistanceBuffer[splatIndex] = depthBits;
	KeyBuffer[splatIndex] = splatIndex;
}
