// Copyright Epic Games, Inc. All Rights Reserved.

//Purpose: Transform 3D splat data → 2D screen-space data

#include "/Plugin/GaussianSplatting/Private/GaussianSplatting.ush"

// Shader parameters
ByteAddressBuffer PositionBuffer;
ByteAddressBuffer OtherDataBuffer;
ByteAddressBuffer SHBuffer;
StructuredBuffer<FGaussianChunkInfo> ChunkBuffer;
Texture2D ColorTexture;
SamplerState ColorSampler;
RWStructuredBuffer<FGaussianSplatViewData> ViewDataBuffer;

float4x4 LocalToWorld;
float4x4 WorldToClip;
float4x4 WorldToView;
float3 CameraPosition;
float2 ScreenSize;
float2 FocalLength;
uint SplatCount;
uint SHOrder;
float OpacityScale;
float SplatScale;
uint2 ColorTextureSize;
uint PositionFormat; // 0=Float32, 1=Norm16, 2=Norm11, 3=Norm6
uint UseDefaultColor; // 1 = use default color (no texture available), 0 = use texture

[numthreads(256, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint splatIndex = DispatchThreadId.x;
	if (splatIndex >= SplatCount)
	{
		return;
	}

	// Load splat data
	float3 localPos;
	if (PositionFormat == 0)
	{
		localPos = LoadPositionFloat32(PositionBuffer, splatIndex);
	}
	else
	{
		localPos = LoadPositionNorm16(PositionBuffer, ChunkBuffer, splatIndex);
	}

	float4 rotation = LoadRotation(OtherDataBuffer, splatIndex);
	float3 scale = LoadScale(OtherDataBuffer, splatIndex) * SplatScale;

	// Load color and opacity from texture (or use default if texture not available)
	float4 colorOpacity;
	if (UseDefaultColor)
	{
		// Default: white with full opacity (debug visualization)
		colorOpacity = float4(1.0, 1.0, 1.0, 1.0);
	}
	else
	{
		colorOpacity = LoadColor(ColorTexture, ColorSampler, splatIndex, ColorTextureSize);
	}
	float opacity = colorOpacity.a * OpacityScale;

	// Transform to world space
	// Note: UE passes matrices that work with mul(vector, matrix) for correct results
	float4 worldPos = mul(float4(localPos, 1.0), LocalToWorld);

	// DEBUG TEST: Uncomment to bypass LocalToWorld and use positions as world coordinates
	// This helps isolate if the issue is in LocalToWorld transformation or position loading
	//worldPos = float4(localPos, 1.0);

	// Transform to clip space
	float4 clipPos = mul(worldPos, WorldToClip);

	// Cull if behind camera (clip space w <= 0 means behind or at camera plane)
	// This is more reliable than checking view space Z which varies by convention
	if (clipPos.w <= 0.0)
	{
		FGaussianSplatViewData viewData;
		viewData.ClipPosition = float4(0, 0, 0, -1); // Mark invalid
		viewData.PackedColorRG = 0;
		viewData.PackedColorBA = 0;
		viewData.Axis1 = float2(0, 0);
		viewData.Axis2 = float2(0, 0);
		ViewDataBuffer[splatIndex] = viewData;
		return;
	}

	// Transform to view/camera space for covariance projection
	float4 viewPos = mul(worldPos, WorldToView);

	// Clamp view position to prevent extreme projections at edge of view (from Unity)
	// Without this, Jacobian terms -fx*x/z^2 explode at extreme angles causing giant splats
	float tanFovX = (ScreenSize.x * 0.5) / FocalLength.x;
	float tanFovY = (ScreenSize.y * 0.5) / FocalLength.y;
	float limX = 1.3 * tanFovX;
	float limY = 1.3 * tanFovY;
	viewPos.x = clamp(viewPos.x / viewPos.z, -limX, limX) * viewPos.z;
	viewPos.y = clamp(viewPos.y / viewPos.z, -limY, limY) * viewPos.z;

	// Calculate 3D covariance from rotation and scale (in local space)
	float3x3 cov3D_local = CalcCovariance3D(rotation, scale);

	// Transform covariance from local space to world space
	// cov_world = R_local * cov_local * R_local^T
	// where R_local is the rotation part of LocalToWorld
	// For row-major matrices: mul(transpose(R), mul(cov, R)) = R * cov * R^T
	float3x3 localToWorldRot = (float3x3)LocalToWorld;
	float3x3 cov3D_world = mul(transpose(localToWorldRot), mul(cov3D_local, localToWorldRot));

	// Get view matrix (upper 3x3)
	float3x3 viewMat = (float3x3)WorldToView;

	// Project to 2D screen covariance (pass view-space position for proper Jacobian)
	float2x2 cov2D = CalcCovariance2D(cov3D_world, viewMat, viewPos.xyz, FocalLength);

	// Decompose into principal axes
	float2 axis1, axis2;
	DecomposeCovariance2D(cov2D, axis1, axis2);

	// Convert axes to NDC space
	// Unity uses quadPos ±2 and multiplies by 2/ScreenParams, giving total factor of 4
	// We use corner ±1, so we need factor of 4 to match: axis_ndc = axis_pixels * 4 / ScreenSize
	axis1 = axis1 / ScreenSize * 4.0;
	axis2 = axis2 / ScreenSize * 4.0;

	// Safety check: clamp axes to reasonable NDC range and handle NaN/Inf
	float maxAxisSize = 2.0;  // Max splat size in NDC (covers full screen)
	if (any(isnan(axis1)) || any(isinf(axis1)) || length(axis1) > maxAxisSize)
	{
		axis1 = float2(0.01, 0.0);  // Fallback to small fixed size
	}
	if (any(isnan(axis2)) || any(isinf(axis2)) || length(axis2) > maxAxisSize)
	{
		axis2 = float2(0.0, 0.01);  // Fallback to small fixed size
	}

	// Calculate view direction for SH
	float3 viewDir = normalize(worldPos.xyz - CameraPosition);

	// Convert view direction from UE (Z-up, X-forward) to 3DGS (Y-up, Z-forward) for SH evaluation
	// UE->3DGS: X->Z, Y->X, Z->Y
	float3 viewDir_3DGS = float3(viewDir.y, viewDir.z, viewDir.x);

	// Evaluate spherical harmonics for view-dependent color
	float3 shColor;
	if (UseDefaultColor)
	{
		// Default color mode: use white (for debug visualization)
		shColor = float3(1.0, 1.0, 1.0);
	}
	else if (SHOrder > 0)
	{
		float3 sh[15];
		LoadSH(SHBuffer, splatIndex, 15, sh);

		// SH DC is stored in color texture, higher bands in SH buffer
		float3 shDC = (colorOpacity.rgb - 0.5) / SH_C0;
		shColor = EvaluateSH(viewDir_3DGS, shDC, sh, SHOrder);
	}
	else
	{
		// Band 0 only - use color from texture
		shColor = colorOpacity.rgb;
	}

	// Clamp color to valid range
	float3 finalColor = max(shColor, 0.0);

	// DEBUG: Use bright colors with full opacity to test if axes are working
	// Comment this block once axes are verified
	float normalizedIndex = float(splatIndex) / float(max(SplatCount, 1));
	finalColor = float3(
		frac(normalizedIndex * 7.0),  // R: cycling pattern
		1.0 - normalizedIndex,         // G: gradient
		normalizedIndex                // B: gradient
	);
	opacity = 1.0;  // Full opacity for debugging

	// Pack and store view data
	FGaussianSplatViewData viewData;
	viewData.ClipPosition = clipPos;
	viewData.PackedColorRG = PackHalf2x16(finalColor.rg);
	viewData.PackedColorBA = PackHalf2x16(float2(finalColor.b, opacity));
	viewData.Axis1 = axis1;
	viewData.Axis2 = axis2;

	ViewDataBuffer[splatIndex] = viewData;
}
